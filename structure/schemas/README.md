# JSON Schemas

> **Validation layer for forge-sdd-toolkit artifacts**

This directory contains JSON Schemas that validate all artifacts generated throughout the SDD lifecycle. These schemas enforce naming conventions, traceability patterns, and structural requirements.

## Schema Inventory

### Document Schemas (Lifecycle Outputs)

#### 1. `specification.schema.json` (433 lines)
**Purpose**: Validates Specification Documents generated by `forge-ideate`

**Validates**:
- Metadata (project, author, created date, status)
- Executive summary
- Project context and scope
- User stories with format `STORY-X.X`
- Acceptance criteria with format `AC-X.X.X`
- Functional requirements (`REQ-F-XXX`)
- Non-functional requirements (`REQ-NFR-XXX`)
- Success metrics and risks
- Priority enums (P0, P1, P2)
- NFR categories (Performance, Scalability, Security, etc.)

**Lifecycle Stage**: IDEATE → ARCHITECT

---

#### 2. `ADD.schema.json` (691 lines)
**Purpose**: Validates Architecture Decision Documents generated by `forge-architect`

**Validates**:
- Metadata with specification traceability
- Module selection decisions (`ADD-MODULE-XXX`)
- UI framework decisions (`ADD-UI-XXX`)
- Data architecture decisions (`ADD-DATA-XXX`)
- API integration decisions (`ADD-API-XXX`)
- Performance budgets (`ADD-PERF-XXX`)
- Security models (`ADD-SEC-XXX`)
- Decision confidence levels (High, Medium, Low)
- Requirement traceability (`REQ-F-XXX`, `REQ-NFR-XXX`)
- Technology enums (UI Kit, Custom UI, React, etc.)

**Lifecycle Stage**: ARCHITECT → PLAN

---

#### 3. `implementation-plan.schema.json` (659 lines)
**Purpose**: Validates Implementation Plans generated by `forge-plan`

**Validates**:
- Metadata with spec and ADD traceability
- Executive summary (effort, timeline, team, milestones)
- Epics with format `EPIC-X`
- User stories with format `STORY-X.X`
- Tasks with format `TASK-X.X.X` (2-8 hour sizing)
- Phases with deliverables and success criteria
- Effort estimation (hours, story points, buffer)
- Quality gates (`GATE-X`)
- Risks (`RISK-X`)
- Definition of Done for tasks, stories, and epics
- Traceability to requirements and architecture decisions

**Lifecycle Stage**: PLAN → IMPLEMENT

---

#### 4. `test-plan.schema.json` (794 lines)
**Purpose**: Validates Test Plans generated by `forge-test`

**Validates**:
- Metadata with full traceability chain (spec, ADD, plan, codebase)
- Test strategy (overview, pyramid, approach, tools)
- Coverage matrix (requirement → test mapping)
- Unit test suites (`SUITE-U-XXX`, `TEST-U-XXX`)
- Integration test suites (`SUITE-I-XXX`, `TEST-I-XXX`)
- E2E test suites (`SUITE-E2E-XXX`, `TEST-E2E-XXX`)
- Performance tests (`TEST-PERF-XXX`)
- Security tests (`TEST-SEC-XXX`)
- Test execution schedule (phases, triggers, frequency)
- Coverage targets (overall, critical paths)
- Quality gates (`QG-X`)
- Test environment configurations

**Lifecycle Stage**: TEST → OPERATE

---

### Configuration Schemas

#### 5. `prompt.schema.json` (48 lines)
**Purpose**: Validates prompt metadata in prompt markdown files

**Validates**:
- Prompt type (prompt, template, specialization)
- Lifecycle stage (ideate, architect, plan, implement, test, operate)
- Level (orchestrator, knowledge, expert)
- Input/output file references

**Used By**: All prompt files in `structure/prompts/`

---

#### 6. `manifest-patch.schema.json` (52 lines)
**Purpose**: Validates Forge manifest patches during implementation

**Validates**:
- Forge manifest structure (modules, permissions, app metadata)
- Module configurations
- Scope declarations
- Resource definitions

**Used By**: `forge-implement` when generating manifest.yml

---

## Schema Statistics

```
Total Schemas: 6
Total Lines: 2,677
Average Complexity: 446 lines/schema

Document Schemas: 4 (2,577 lines)
Configuration Schemas: 2 (100 lines)
```

## Usage in CLI Scripts

### Validation Pipeline

```typescript
import Ajv from 'ajv';
import addFormats from 'ajv-formats';

const ajv = new Ajv({ allErrors: true });
addFormats(ajv);

// Load schema
const schema = require('./schemas/specification.schema.json');
const validate = ajv.compile(schema);

// Validate document
const valid = validate(document);
if (!valid) {
  console.error('Validation errors:', validate.errors);
  process.exit(1);
}
```

### Stage-Specific Validation

| Stage | Input Validation | Output Validation |
|-------|------------------|-------------------|
| **IDEATE** | - | `specification.schema.json` |
| **ARCHITECT** | `specification.schema.json` | `ADD.schema.json` |
| **PLAN** | `ADD.schema.json` | `implementation-plan.schema.json` |
| **IMPLEMENT** | `implementation-plan.schema.json` | `manifest-patch.schema.json` |
| **TEST** | Code + Plan | `test-plan.schema.json` |
| **OPERATE** | Tests + Plan | - (operational docs) |

## Naming Conventions Enforced

### Requirement IDs
- Functional: `REQ-F-001` through `REQ-F-999`
- Non-Functional: `REQ-NFR-001` through `REQ-NFR-999`

### Story & Task IDs
- Epics: `EPIC-1`, `EPIC-2`, etc.
- Stories: `STORY-1.1`, `STORY-1.2`, etc.
- Acceptance Criteria: `AC-1.1.1`, `AC-1.1.2`, etc.
- Tasks: `TASK-1.1.1`, `TASK-1.1.2`, etc.

### Architecture Decision IDs
- Module: `ADD-MODULE-001` through `ADD-MODULE-999`
- UI: `ADD-UI-001` through `ADD-UI-999`
- Data: `ADD-DATA-001` through `ADD-DATA-999`
- API: `ADD-API-001` through `ADD-API-999`
- Performance: `ADD-PERF-001` through `ADD-PERF-999`
- Security: `ADD-SEC-001` through `ADD-SEC-999`

### Test IDs
- Unit Tests: `TEST-U-001` through `TEST-U-999`
- Integration Tests: `TEST-I-001` through `TEST-I-999`
- E2E Tests: `TEST-E2E-001` through `TEST-E2E-999`
- Performance Tests: `TEST-PERF-001` through `TEST-PERF-999`
- Security Tests: `TEST-SEC-001` through `TEST-SEC-999`
- Test Suites: `SUITE-U-001`, `SUITE-I-001`, `SUITE-E2E-001`

### Quality & Risk IDs
- Quality Gates: `GATE-1`, `GATE-2`, etc.
- Quality Gates (Test): `QG-1`, `QG-2`, etc.
- Risks: `RISK-1`, `RISK-2`, etc.
- Test Risks: `RISK-TEST-1`, `RISK-TEST-2`, etc.

## Traceability Enforcement

All schemas enforce **full traceability** from user requirements to implementation:

```
User Requirement (REQ-F-001)
  ↓
Architecture Decision (ADD-MODULE-001)
  ↓
Epic (EPIC-1)
  ↓
User Story (STORY-1.1)
  ↓
Acceptance Criterion (AC-1.1.1)
  ↓
Task (TASK-1.1.1)
  ↓
Test (TEST-U-001)
```

Every artifact at every stage must reference its parent artifacts, creating an unbroken chain from idea to deployed feature.

## Error Messages

Schemas provide clear error messages when validation fails:

```json
{
  "keyword": "pattern",
  "dataPath": ".requirements[0].id",
  "message": "should match pattern \"^REQ-F-\\d{3}$\"",
  "params": {
    "pattern": "^REQ-F-\\d{3}$"
  }
}
```

## Future Enhancements

### Additional Schemas (v0.2+)
- `deployment-plan.schema.json` - For OPERATE stage deployment guides
- `runbook.schema.json` - For operational runbooks
- `adr.schema.json` - For Architecture Decision Records
- `template.schema.json` - For validating template metadata
- `specialization.schema.json` - For validating specialization metadata

### Enhanced Validation
- Cross-document reference validation (ensure `REQ-F-001` exists when referenced)
- Chronological validation (ensure dates/phases are sequential)
- Effort calculation validation (task hours sum to story hours)
- Coverage completeness (ensure all requirements have tests)

## Contributing

When adding new schemas:

1. Follow JSON Schema Draft 07 specification
2. Include `$schema` and `$id` properties
3. Add comprehensive `description` fields
4. Enforce naming patterns with regex
5. Use enums for controlled vocabularies
6. Document in this README
7. Add validation examples in CLI scripts

## References

- [JSON Schema Specification](https://json-schema.org/)
- [AJV Validator](https://ajv.js.org/)
- [SDD Methodology](../docs/SDD_METHODOLOGY.md)
- [Lifecycle Stages](../docs/LIFECYCLE_STAGES.md)
